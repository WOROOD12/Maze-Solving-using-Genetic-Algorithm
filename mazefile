!pip install pymoo

import numpy as np
import time
import pandas as pd
import matplotlib.pyplot as plt
import random
from pymoo.core.problem import Problem
from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.termination import get_termination
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from pymoo.optimize import minimize

# Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØ§Ù‡Ø©
def load_maze(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    maze = [list(line.strip()) for line in lines if line.strip()]
    start = (0, 0)
    goal = (len(maze)-1, len(maze[-1])-1)
    return maze, start, goal

# Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙÙŠÙ‡ Ø¬Ø¯Ø§Ø±
def is_wall(pos, maze):
    x, y = pos
    return not (0 <= x < len(maze) and 0 <= y < len(maze[0])) or maze[x][y] == '#'

# Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ØµØ§Ù„Ø­Ø©
def get_valid_moves(position, maze):
    valid = []
    x, y = position
    for i, (dx, dy) in enumerate(directions):
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] != '#':
            valid.append(i)
    return valid

# Ø¯Ø§Ù„Ø© Ù…ÙŠÙˆØªÙŠØ´Ù† Ø®Ø§ØµØ© (ØªØ­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø¶Ø±Ø¨ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†)
def maze_aware_mutation(individual, maze, start):
    x, y = start
    for idx in range(len(individual)):
        move = individual[idx]
        dx, dy = directions[int(move)]
        nx, ny = x + dx, y + dy

        if not (0 <= nx < len(maze) and 0 <= ny < len(maze[0])) or maze[nx][ny] == '#':
            valid_moves = get_valid_moves((x, y), maze)
            if valid_moves:
                individual[idx] = random.choice(valid_moves)

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø±ÙƒØ©
        move = individual[idx]
        dx, dy = directions[int(move)]
        x, y = x + dx, y + dy
    return individual

# ÙƒÙ„Ø§Ø³ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
class SmartMazeProblem(Problem):
    def __init__(self, maze, start, goal, max_steps):
        super().__init__(n_var=max_steps, n_obj=1, n_constr=0, xl=0, xu=3, type_var=np.int32)
        self.maze = maze
        self.start = start
        self.goal = goal
        self.max_steps = max_steps

    def _evaluate(self, X, out, *args, **kwargs):
        fitness = []
        for path in X:
            x, y = self.start
            visited = set()
            for move in path:
                dx, dy = directions[int(move)]
                nx, ny = x + dx, y + dy
                if 0 <= nx < len(self.maze) and 0 <= ny < len(self.maze[0]) and self.maze[nx][ny] != '#':
                    x, y = nx, ny
                visited.add((x, y))
            dist = abs(x - self.goal[0]) + abs(y - self.goal[1])
            reward = 0 if (x, y) != self.goal else -100
            fitness.append(dist + reward + (self.max_steps - len(visited)) * 0.01)
        out["F"] = np.array(fitness)

# Ø¯Ø§Ù„Ø© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø¹Ù„Ù‰ Ù…ØªØ§Ù‡Ø© ÙˆØ§Ø­Ø¯Ø©
def run_experiment(maze_file, label, max_steps):
    maze, start, goal = load_maze(maze_file)
    results = []

    for gen in [1000, 10000, 50000]:
        problem = SmartMazeProblem(maze, start, goal, max_steps=max_steps)

        # ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙƒØ±ÙˆØ³ Ø£ÙˆÙØ± ÙˆØ§Ù„Ù…ÙŠÙˆØªÙŠØ´Ù†
        crossover = SBX(prob=0.9, eta=15)
        mutation = lambda x: maze_aware_mutation(x, maze, start)

        algorithm = GA(
            pop_size=100,
            crossover=crossover,
            eliminate_duplicates=True
        )

        termination = get_termination("n_gen", gen)

        start_time = time.time()
        res = minimize(problem, algorithm, termination, seed=42, verbose=False)
        end_time = time.time()

        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ÙŠÙˆØªÙŠØ´Ù† Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ²Ø§ÙˆØ¬
        maze_aware_mutation(res.X, maze, start)

        results.append({
            "generations": gen,
            "best_fitness": res.F[0],
            "path_cost": len(set(res.X)),
            "execution_time": round(end_time - start_time, 2)
        })

    df = pd.DataFrame(results)
    print(f"\nğŸ”¹ Results for {label} Maze:")
    print(df)

    # Ø§Ù„Ø±Ø³Ù…
    plt.figure(figsize=(10, 4))
    plt.plot(df["generations"], df["best_fitness"], marker='o')
    plt.title(f"Best Fitness vs Generations ({label} Maze)")
    plt.xlabel("Generations")
    plt.ylabel("Best Fitness")
    plt.grid(True)
    plt.show()

    plt.figure(figsize=(10, 4))
    plt.plot(df["generations"], df["path_cost"], marker='o')
    plt.title(f"Path Cost vs Generations ({label} Maze)")
    plt.xlabel("Generations")
    plt.ylabel("Unique Steps Taken")
    plt.grid(True)
    plt.show()

    plt.figure(figsize=(10, 4))
    plt.plot(df["generations"], df["execution_time"], marker='o')
    plt.title(f"Execution Time vs Generations ({label} Maze)")
    plt.xlabel("Generations")
    plt.ylabel("Time (seconds)")
    plt.grid(True)
    plt.show()

    return df

# ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ¬Ø§Ø±Ø¨
df_100 = run_experiment("maze_100x1002.txt", "100x100", max_steps=300)
df_200 = run_experiment("maze_200x2002.txt", "200x200", max_steps=500)
